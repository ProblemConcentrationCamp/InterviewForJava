# 04. synchronized 关键字


## 1. synchronized 的使用
![Alt 'synchroized'](https://s2.ax1x.com/2020/01/03/lalNFO.png)

如图： synchronized 可以用在 **实例方法**, **静态方法**, **代码块**上。其中，修饰代码块的话, 根据锁的对象的不同，可以继续细分为 3 种。

注：自己粗心踩过的一个坑
```java
public void method() {
    // 此时锁的不是 class 而是当前类的实例
    synchronized(SynchronizedDemo.this) {
    }   
}
```


## 2. 不同的用法在字节码上显示区别

**synchronized 锁方法**  
```java
/** 修饰 静态方法*/
public static synchronized void fn1() {
    int num = 1;
    num ++;
    System.out.println("num:" + num);
}
```

注：[Idea 查看字节码的方法](https://blog.csdn.net/21aspnet/article/details/88351875)

上面的代码编译为字节码为：
```class
public static synchronized void fn1();
descriptor: ()V
flags: (0x0029) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
Code:
  stack=2, locals=1, args_size=0
     0: iconst_1
     1: istore_0
     2: iinc          0, 1
     5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     8: iload_0
     9: invokedynamic #3,  0              // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;
    14: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    17: return
  LineNumberTable:
    line 15: 0
    line 16: 2
    line 17: 5
    line 18: 17
  LocalVariableTable:
    Start  Length  Slot  Name   Signature
        2      16     0   num   I
```
我们可以看到在 flags 后面多了一个 ACC_SYNCHRONIZED 的标识(可以把 synchronized 去掉打包后比较一下)，说明标识作用是告诉 JVM 这是一个同步方法(非静态方法也是一样的)，进入这个方法之前需要先获取锁。

**synchronized 锁代码块**
```java
/** 修饰 代码块: 锁当类对象 */
public void fn3() {
    synchronized (DemoOne.class) {
        int num = 1;
        num ++;
        System.out.println("num:" + num);
    }
}
```

上面的代码编译为字节码为：
```class
public void fn3();
descriptor: ()V
flags: (0x0001) ACC_PUBLIC
Code:
  stack=2, locals=4, args_size=1
     0: ldc           #5                  // class com/can/DemoOne
     2: dup
     3: astore_1
     4: monitorenter
     5: iconst_1
     6: istore_2
     7: iinc          2, 1
    10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
    13: iload_2
    14: invokedynamic #3,  0              // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;
    19: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    22: aload_1
    23: monitorexit
    24: goto          32
    27: astore_3
    28: aload_1
    29: monitorexit
    30: aload_3
    31: athrow
    32: return
  Exception table:
     from    to  target type
         5    24    27   any
        27    30    27   any
  LineNumberTable:
    line 29: 0
    line 30: 5
    line 31: 7
    line 32: 10
    line 33: 22
    line 34: 32
  LocalVariableTable:
    Start  Length  Slot  Name   Signature
        7      15     2   num   I
        0      33     0  this   Lcom/can/DemoOne;
  StackMapTable: number_of_entries = 2
    frame_type = 255 /* full_frame */
      offset_delta = 27
      locals = [ class com/can/DemoOne, class java/lang/Object ]
      stack = [ class java/lang/Throwable ]
    frame_type = 250 /* chop */
      offset_delta = 4
```
我们查看 上面的 **Code** 模块，会发有 1 个 **monitorenter** 和 2 个 **monitorexit**。其中的 monitorenter 和 第一个 monitorexit 同样是告诉 JVM 这是一个同步代码块，进入之前需要先获取锁。至于第二个 monitorexit 是用于异常处理的，当我们的代码块出现了异常，这时第一个 monitorexit 不会经过，而是到了 第二个 monitorexit，这样可以确保我们的锁能够正确的释放。


## 3. Java 对象内存分布（了解 synchronize 的基础）
在 JVM 中每个对象实例都由 3 部分组成：对象头（Header）, 实例数据（Instance Data） 和对齐填充（Padding）。其中实例数据和对齐填充和 synchronized 没有什么关系。没有多大关系这里就简单说一下。

**实例数据:** 对象真正有效的信息，也就是我们类中声明的各个字段（包括从父类继承下来的）

**对齐填充:** 这个不是必须，也没有具体的含义，只是单纯的起占位作用。他的出现与否取决于当前对象实例的内存大小。

理解对齐填充  
为了提高内存访问效率，JVM 规定了每个对象在内存中的存储的大小必须是 8 字节的倍数。这样的话，
Java 对象头 + 实例数据的内存大小如果不是 8 的倍数，那么这时候对齐填充就出现了，当前还差多少，就给这个对象填充多少字节，凑齐 8 的倍数。如果刚好是 8 的倍数了，那么对齐填充就没必要出现了。


**对象头**  
对象头是 synchronized 实现锁的基础。synchronized 的上锁，释放锁等都是借助对象头实现的。在 JVM 中对象头有 2 种方式
>1. 普通对象 = Mark Word + Klass Word 
>2. 数组对象 = Mark Word + Klass Word + array lenght(数组的长度)

[注]： Klass Word 部分我看到过有别的名称如：Klass Pointer, Class Metadata Address 等，虽然不敢笃定那个是正确的，但是他们都是表示同一个东西。

`Mark Word:` 主要用于存储对象在运行时的信息，如 hashCoce, gc 分代年龄。Mark Word 的内存大小取决于 JVM 的位数。如果 32 位 的 JVM, 那么 Mark Word 就是 32 个字节。同理的 64 位 JVM 就是 64 个字节。Mark Word 的组成（任意时刻只存在其中的一种状态）

32 位的 Mark Word  
![Alt '32 位 Mark Word'](https://s2.ax1x.com/2020/01/05/lBTXY4.png)

64 位的 Mark Word  
![Alt '64 位 Mark Word'](https://s2.ax1x.com/2020/01/05/lBTOkF.png)

`Klass Word:`用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。同样的 Klass Word 的内存大小也是取决于 JVM 的位数。32 位 JVM 就是 32 个字节，64 位 JVM 就是 64个字节。（从上面可以知道，64位的 JVM 消耗的内存是 32 位的多 50% 的消耗。对于一个对象的引用，64 位的 JVM 需要多 32 字节来存储对象的引用。在 JDK6 上可以在启动项目时加上 ` -XX:+UseCompressedOops` 来对这种现象进行压缩，节省空间，但是它的实现方式是在机器码中植入压缩与解压指令，可能会给JVM增加额外的开销）

`array lenght(数组的长度):` 如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。


## 4. synchronized 在 JDK6 之后的优化

** 锁消除 **
在动态编译同步块的时候， JIT编译器可以借助一种被称为逃逸分析（ Escape Analysis）的技术来判断同步块所使用的 锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果是的话，就不为其生成 synchronized 的相关的字节码指令。
```java
public void method() {
    // jit 通过逃逸判断出方法有且只有一个线程会执行到，会将其优化
    synchronized(Lock.class) {
        doSomethings();
    }
}

public void method() {
    // 优化后的等效代码
    doSomethings();
}
```

**锁粗化**
对于相邻的几个同步块， 如果这些同步块使用的是同一个锁实例， 那么 JIT 编译器会将这些同步块合并为一个大同步 块， 从而避免了一个线程反复申请、 释放同一个锁所导致的开销。

```java
public void method() {
    for (int i = 0; i < 10; i++) {
        synchronized(Lock.class) {
            doSomethings1();
        }
    }
}

// 优化后
public void method() {
    synchronized(Lock.class) {
        for (int i = 0; i < 10; i++) {
            doSomethings();
        }
    }
}
```

**自旋锁**
在申请一个锁时，如果这个锁被另一个线程持有着，那么当前的线程就需要被挂起，进入阻塞状态。但是很多时候，锁的持有时间很多，这时候挂起线程不值得，可以让当前线程执行循环等待锁释放，不让出 CPU。待锁释放时，在进行锁获取。在指定的获取锁失败的时间内，还没获取到锁的话，再将其挂起。但是这种优化存在问题：锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。

**自适应自旋锁**
在自旋锁的基础上进行优化：它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

**锁膨胀(锁升级)**
从 Mark Word 我们可以看到好几个锁的名词，其实 synchronized 在我们使用过程中存在着一个升级的过程, 他不会直接就去获取锁，而是在运行中，根据线程对锁的竞争程度，逐渐升级 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁。在我们日常的认知中，可能就是单纯的认为是 无锁 -> 重量级锁的过程（JDK6之前的确是这样子，但是在 6 之后进行了优化，修改为锁逐渐升级的模式）。



## 4. 锁膨胀(锁升级)

先上图:
![Alt 'synchronized 锁升级流程图'](https://s2.ax1x.com/2020/01/05/lD47tJ.png)


### 偏向锁
在大多数情况下，锁是不存在竞争的，而且总是由一个线程持有，所以可以在使用 synchronized 的时候，可以不去真正的获取锁，而减少获取锁的代价。

获取锁过程：
1) 进入同步代码块，获取对象头的 Mark Work
2) 判断当前锁的状态，是否为 01，不是的话, 说明当前对象处于其他锁状态，后续讨论
3）当前的锁状态为 01， 然后判断是否为偏向锁的位置是否 1, 如果为 1， 说明现在处于偏向锁状态，走步骤 4, 如果为 0 ，说明现在处于 无锁状态，走步骤 5
4) 判断对象头里面的 ThreadId 是否等于当前线程的 Id， 如果时，执行代码块，如果不是走步骤 5
5）通过 CAS 替换 ThreadId 为 当前线程的Id， 替换成功，执行代码块，失败，表示当前存在多个线程竞争锁，走步骤 6
6）开始偏向锁撤销，等待原持有偏向锁的线程达到安全点(在这个是时间点上没有字节码正在执行), 暂停持有偏向锁的线程，根据持有偏向锁的线程的状态，进入锁撤销或者锁升级






https://juejin.im/post/5c936018f265da60ec281bcb


https://www.cnblogs.com/tiancai/p/9382542.html




过程：在 Mark Word 的无锁状态，通过是否为偏向锁和锁标识知道当前线程为无锁状态，那么直接进入到偏向锁状态就行了。
![Alt '无锁-> 偏向锁'](https://s2.ax1x.com/2020/01/05/lD3j5n.png)

### 偏向锁 -> 轻量级锁
不存在偏向锁直接转为轻量级锁。当一个偏向锁需要转为轻量级锁时，会先转为无锁状态，然后无锁状态转为轻量级锁

### 轻量级锁 -> 重量级锁















### 2.4 锁的本质
在 JVM 中 每个对象都有一个 monitor 和他对应。这里的 monitor 就能看作是我们说的锁对象。在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor（C++ 代码实现的）创建的。Java 对象和 monitor 的实现方式有多种。如： 创建对象的时候，monitor 也跟着创建，也可以在线程试图获取这个对象的锁是自动生成。

因为 synchronized 具体的实现逻辑都是在 JVM 内部实现好了，所以此处就简单的说一下我了解到的（基于 HotSpot）。
```c++
ObjectMonitor() {
    _header       = NULL;       // markOop对象头
    _count        = 0;          // 锁的计数器    
    _waiters      = 0,          // 等待线程数
    _recursions   = 0;          // 重入次数
    _object       = NULL;       // 监视器锁寄生的对象。锁不是平白出现的，而是寄托存储于对象中
    _owner        = NULL;       // 指向获得ObjectMonitor对象的线程或基础锁
    _WaitSet      = NULL;       // 处于wait状态的线程，会被加入到wait set
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;      // 处于等待锁block状态的线程，会被加入到entry set；
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;         // _owner is (Thread *) vs SP/BasicLock
    _previous_owner_tid = 0;    // 监视器前一个拥有者线程的ID
  }
```

注：这里聊的是重量级锁的原理，直接跳过了偏向锁，轻量级锁的过程。


### 2.1 原理
在 JVM 中每个对象都有一个自己的锁对象 (monitor)。synchronized 的 2 种使用方式，实现原理都是一样的：在进入同步代码时，会尝试获取需要对象的锁，也就是 monitor, 如果获取成功, 锁的计数器就会 +1，进入同步代码，执行完成后，将锁的计数器 -1。如果尝试获取锁失败时，就将当前线程阻塞 (Blocking)。而 2 种方式的区别的话，需要通过他们的字节码进行查看了。 其中锁方法的话，在字节码上，这个方法会在 `flags` 上加上 `ACC_SYNCHRONIZED` 表示这个方法是同步方法，而锁代码块的话，这是在锁住的代码块的开始结束处，加上 `monitorenter` 和 `monitorexit` 进行标识。(这里先说了结论，具体的说明看下面)。





## 参考
[深入理解synchronized底层原理，一篇文章就够了](https://cloud.tencent.com/developer/article/1465413)  
[jdk源码剖析二: 对象内存布局、synchronized终极原理](https://www.cnblogs.com/dennyzhangdd/p/6734638.html#_label0_1)

