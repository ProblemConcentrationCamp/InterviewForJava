# 05. volatile 关键字

## 1. 作用
>1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
>2. 禁止进行指令重排序

## 2. 使用
```java
public class Demo {
    // 直接修饰 类中的属性
    private volatile String name;
}

```

## 3. 原理
```java
instance = new Singleton();
```

生成的汇编指令中

| 是否被 volatile 修饰 | 指令  |
| :-: |:-: |
| instance | 0x01a3de1d: movb $0x0,0x1104800(%esi); |
| instance  | 0x01a3de1d: movb $0x0,0x1104800(%esi); <br/>  0x01a3de24: **lock** addl $0x0,(%esp); |

我们可以发现 被 volatile 修饰的变量进行写操作的时候会多第二行汇编代码。这行代码里面有一个 lock 的前缀的指令。lock 前缀的指令在多核处理器的作用下，具有
>1. 将当前处理器缓存行的数据会写回到系统内存
>2. 这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效

处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2 或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了 Volatile 变量进行写操作，JVM 就会向处理器发送一条 **Lock 前缀的指令**，将这个变量所在**缓存行**的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**，每个处理器通过**嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成**无效状态**，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。



## 参考
[聊聊并发（一）——深入分析 Volatile 的实现原理](https://www.infoq.cn/article/ftf-java-volatile)
[彻底理解volatile](https://www.codercc.com/post/e43d1141.html)
