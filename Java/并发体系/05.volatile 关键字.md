# 05. volatile 关键字

## 1. 作用
>1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
>2. 禁止进行指令重排序

## 2. 使用
```java
public class Demo {
    // 直接修饰 类中的属性
    private volatile String name;
}

```

## 3. 原理
```java
instance = new Singleton();
```
生成的汇编指令中
| 是否被 volatile 修饰 | 指令  |
| :-: |:-: |
| instance | 0x01a3de1d: movb $0x0,0x1104800(%esi); |
| instance  | 0x01a3de1d: movb $0x0,0x1104800(%esi); <br/>  0x01a3de24: **lock** addl $0x0,(%esp); |

我们可以发现 被 volatile 修饰的变量进行写操作的时候会多第二行汇编代码。这行代码里面有一个 lock 的前缀的指令。lock 前缀的指令在多核处理器的作用下，具有
>1. 将当前处理器缓存行的数据会写回到系统内存
>2. 这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效

处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2 或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了 Volatile 变量进行写操作，JVM 就会向处理器发送一条 **Lock 前缀的指令**，将这个变量所在**缓存行**的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**，每个处理器通过**嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成**无效状态**，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

从上面的结论能知道

 >1. volatile 修饰的变量，在对其写的时候，会在后面加多一个 Lock 前缀的指令
 >2. Lock 前缀的这个指令，会导致变量的最新值刷新到主内存，通过缓存一致性协议实现的
 >3. 回写到主内存的数据会导致其他处理器的缓存失效，使其重新到主内存读取最新的值

 
## 4. volatile 和 happens-before 的关系

volatile 变量原则：对一个 volatile 变量的写操作 happens-before 于后续每一个针对该变量的读操作。

```java
public class Demo {
 
 private int a = 0;
 
 private volatile boolean flag = false;
 
 public void write() {
    // 1
    a = 1;
    // 2
    flag = true;
 }
 
 public void read() {
    // 3
    if (flag) {
        // 4
        int num = a;
    }   
 }
}
```

![Alt 'Concurrency happens before关系推导'](https://s2.ax1x.com/2020/01/13/lHoVC8.png)

假设线程 A 执行完 write 方法， 线程 B 执行完 read 方法。
通过 happens-before 的程序顺序原则，我们可以推导出黑色箭头的执行顺序，
按照 volatile 原则可以指定 红色箭头的执行顺序。如果存在 A happens-before B，那么 A 之前的操作对于 B 可见，所以可以推导出蓝色的结果。得到的结论就是：volatile 变量的修改，能够立即被其他线程获取到。

## 5. volatile 和 JMM 的关系
还是上面的代码

>1. 线程 A 先从主内存读取到 a = 0，flag = false 到自己的 本地内存。
>2. 将 a + 1, 把 a = 2, 放到 本地内存
>3. 将 flag = true, 放到本地内存，同时在 volatile 的作用下，将当前相关操作的本地内存
值刷新到主内存，并且间接的使得其他线程的本地内存失效
>4. 线程 B 需要的数据失效了，从主内存读取，从而达到了 A 修改的值，B 能立即读到

## 6. 有序性的实现

我们知道, 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。有时候重排序会导致执行结果的不正确。所以在有些情况下，JMM 为了结果的执行准确性，会禁止指令的重排序。实现的方式就是通过内存屏障实现的。

JMM把内存屏障指令分为4类：
| 屏障类型| 说明 | 实例 |
| :-: | :-: | :-: |
| LoadLoadBarriers| Load1; LoadLoadBarriers; Load2 | 确保 Load1 数据的读取 在 load2 及 后续指令的读取之前|
| StoreStoreBarriers | Store1; StoreStoreBarriers; Store2; | 确保 Store1 数据的写入(刷新到主内存) 在 Store2 及后续指令的读取之前 |
|LoadStoreBarriers| Load1; LoadStoreBarriers; Store2; | 确保 Load1 数据的读取 在Store2 及后续指令的写入之前 |
| StoreLoadBarriers | Store1; StoreLoadBarriers; Load2; | 确保 Store2 数据的写入 在 Load2 及后续指令的读取之前 |

为了实现volatile内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的**处理器重排序**。。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM采取了保守策略：

>1. 在每个volatile写操作的**前面**插入一个StoreStore屏障
>2. 在每个volatile写操作的**后面**插入一个StoreLoad屏障
>3. 在每个volatile读操作的**后面**插入一个LoadLoad屏障
>4. 在每个volatile读操作的**后面**插入一个LoadStore屏障

对于 volatile 的写是分别在前后加入 1 个内存屏障，而读是在后面加入 2 个内存屏障。  
分析：






## 参考
[聊聊并发（一）——深入分析 Volatile 的实现原理](https://www.infoq.cn/article/ftf-java-volatile)  
[彻底理解volatile](https://www.codercc.com/post/e43d1141.html)
