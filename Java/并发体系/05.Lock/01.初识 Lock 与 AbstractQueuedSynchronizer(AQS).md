# 01. 初识 Lock 与 AbstractQueuedSynchronizer(AQS)

## 1. concurrent 包的结构层次
在 Java 中并发的操作的大部分都是在 java.util.concurrent。里面包含了大量实用，高性能的工具类, 包的结构如下：
![Alt 'package structure'](https://s2.ax1x.com/2020/02/28/3BEDeI.png)  

(上面的图并不是) 从图中我们可以知道: 包含了 2 个子包：atomic 和 locks，还包含了BlockQueue 和 Executors, 而这些类的实现主要是依赖于 volatile 以及 CAS），从整体上来看 concurrent 包的整体实现图如下图所示：
![Alt '实现'](https://s2.ax1x.com/2020/02/28/3BmZnJ.png)

## 2. lock 简介
接下来我们看一下 concurent 包下的 lock 子包。锁是用来控制多个线程访问共享资源的方式。一般来说，一个锁能够防止多个线程同时访问共享资源。在 Lock 接口出现之前，java 程序主要是靠 synchronized 关键字实现锁功能的，而 java SE5 之后，并发包中增加了 Lock 接口，它提供了与 synchronized 一样的锁功能。虽然它失去了像 synchronize 关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。通常使用显示使用lock的形式如下：
```java
Lock lock = new ReentrantLock();
lock.lock();
try{
	.......
}finally{
	lock.unlock();
}
```
synchronized 同步块执行完成或者遇到异常都会自动释放，而 Lock 必须手动地调用 unlock() 方法释放锁，因此在 finally 块中释放锁,确保锁的释放。

### 2.1 Lock 接口的 Api
```java
public interface Lock {
    
    /** 获取锁 */
    void lock();
    
    /** 获取锁的过程能够响应中断 */
    void lockInterruptibly() throws InterruptedException;
    
    /** 非阻塞式的获取锁，获取锁成功返回true，反之返回fasle */
    void tryLock();
    
    /** 在指定时间内等待获取锁, 过程中可被中断 */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    
    /** 锁释放 */
    void unlock();
    
    /** 
     * 获取与lock绑定的等待通知组件
     * 当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回
     */
    Condition newCondition();
}
```

Lock 的实现类大部分都是内部类，我们能够直接使用的话就是 ReentrantLock, 可重入锁。
ReentrantLock 的实现不复杂，同时可以发现 **基本上所有的方法的实现实际上都是调用了其静态内存类 Sync 中的方法,而 Sync 类继承了 AbstractQueuedSynchronizer（AQS）**。。可以看出要想理解 ReentrantLock 关键核心在于对队列同步器 AbstractQueuedSynchronizer（简称同步器）的理解。
